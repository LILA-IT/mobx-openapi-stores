import { action, computed, flow, makeObservable, observable } from 'mobx';
import { toFlowGeneratorFunction } from 'to-flow-generator-function';

import { callApi } from '../utils/api';

import { type ApiConfig, type ApiType } from '../types/ApiType';
import { LoadingStore } from './LoadingStore';

/**
 * @class ApiStore
 * @template TApi - The type of the generated API client (e.g., PetApi from openapi-generator).
 * @template TConfig - The configuration type required by the TApi client constructor.
 * @description Base store for managing an API client instance and making API calls.
 * It extends `LoadingStore` to provide loading state indicators during API interactions.
 *
 * This store provides two ways to initialize the API client:
 * 1. Pass a `createApi` function in the constructor options
 * 2. Override the `initApi` method in a subclass
 *
 * @extends LoadingStore
 *
 * @property {TApi | null} api - The observable API client instance. Null until `initApi` is successfully called.
 * @property {boolean} apiIsSet - A computed property that returns true if the API client has been initialized.
 * @property {string} name - The name of the store instance (used for logging and debugging).
 *
 * @method setApi - Action to set the API client instance.
 * @method initApi - Initializes the API client. Can be overridden by subclasses or uses the `createApi` function if provided.
 * @method apiCall - A MobX flow-wrapped method for making generic API calls using the initialized API client.
 *
 * @example
 * // Using createApi function (recommended for simple cases)
 * const myApiStore = new ApiStore({
 *   name: 'MyApiStore',
 *   createApi: (config) => new MyGeneratedApi(config)
 * });
 *
 * @example
 * // Assume MyGeneratedApi is a class generated by OpenAPI generator
 * // and MyApiConfig is its configuration type.
 * // Extending with custom initApi (recommended for complex initialization)
 * class MySpecificApiStore extends ApiStore<MyGeneratedApi, MyApiConfig> {
 *   constructor(name: string) {
 *     super(name);
 *     makeObservable(this, { initApi: override }); // Important for MobX
 *   }
 *
 *   initApi(config: MyApiConfig) {
 *     this.setApi(new MyGeneratedApi(config));
 *   }
 *
 *   async fetchSomeData(id: string) {
 *     // 'someEndpoint' would be a method key on MyGeneratedApi
 *     // The arguments { id } would match the parameters of MyGeneratedApi.someEndpoint
 *     return await this.apiCall('someEndpoint', { id });
 *   }
 * }
 *
 * @example
 * // Backwards compatible usage
 * class LegacyApiStore extends ApiStore<MyApi> {
 *   constructor() {
 *     super('LegacyApiStore'); // Old signature still works
 *   }
 * }
 */
export class ApiStore<
  TApi extends ApiType,
  TConfig extends ApiConfig<TApi> = ApiConfig<TApi>,
> extends LoadingStore {
  /**
   * @property {TApi | null} api
   * @description The observable API client instance. It is `null` until `initApi` is successfully called and `setApi` populates it.
   *              Used by `apiCall` to execute requests.
   * @observable
   */
  api: TApi | null = null;

  /**
   * @property {((config: TConfig) => TApi) | null} createApi
   * @description Optional factory function to create the API client instance.
   *              If provided, it will be used by the default `initApi` implementation.
   * @private
   */
  private createApi: ((config: TConfig) => TApi) | null = null;

  /**
   * @property {string} name
   * @description The name of the store instance, used for logging and debugging.
   *              Defaults to the class name if not provided.
   */
  name: string;

  /**
   * @constructor
   * @description Creates a new ApiStore instance. Supports both legacy and new constructor signatures for backwards compatibility.
   * @param {string | { name?: string; createApi?: (config: TConfig) => TApi }} [nameOrOptions]
   *        - Legacy: A string representing the store name
   *        - New: An options object with optional name and createApi function
   *
   * @example
   * // Legacy signature (backwards compatible)
   * const store1 = new ApiStore('MyStore');
   *
   * @example
   * // New signature with name only
   * const store2 = new ApiStore({ name: 'MyStore' });
   *
   * @example
   * // New signature with createApi function
   * const store3 = new ApiStore({
   *   name: 'MyStore',
   *   createApi: (config) => new MyApi(config)
   * });
   *
   * @example
   * // Minimal usage (name will default to class name)
   * const store4 = new ApiStore();
   */
  constructor(
    nameOrOptions?: string | { name?: string; createApi?: (config: TConfig) => TApi },
  ) {
    super();

    // Handle backwards compatibility and flexible constructor signatures
    if (typeof nameOrOptions === 'string') {
      // Legacy signature: constructor(name: string)
      this.name = nameOrOptions;
      this.createApi = null;
    } else if (nameOrOptions && typeof nameOrOptions === 'object') {
      // New signature: constructor({ name?, createApi? })
      this.name = nameOrOptions.name ?? this.constructor.name;
      this.createApi = nameOrOptions.createApi ?? null;
    } else {
      // No arguments provided
      this.name = this.constructor.name;
      this.createApi = null;
    }

    makeObservable(this, {
      initApi: action.bound,
      setApi: action,
      apiIsSet: computed,
      api: observable,
      name: false,
      apiCall: flow,
    });

    this.setIsLoading(true); // Typically, an API store might start by fetching initial data or waiting for config.
  }

  /**
   * @method setApi
   * @description Sets the API client instance for the store. Typically called from within `initApi`.
   * @param {TApi} api - The API client instance.
   * @action
   */
  setApi = (api: TApi) => {
    this.api = api;
    this.setIsLoading(false);
  };

  /**
   * @method initApi
   * @description Initializes the API client. This method can be implemented in two ways:
   *              1. If a `createApi` function was provided in the constructor, it will be used automatically
   *              2. Override this method in subclasses for custom initialization logic
   * @param {TConfig} config - The configuration object required by the API client (e.g., base path, middleware).
   * @throws {Error} If neither `createApi` function was provided nor the method was overridden by a subclass.
   * @action bound
   */
  initApi(config: TConfig) {
    if (this.createApi) {
      this.setApi(this.createApi(config));
    } else {
      throw new Error(
        `initApi is not implemented for ${this.name}. Either provide a 'createApi' function in the constructor options or override the 'initApi' method in your subclass.`,
      );
    }
  }

  /**
   * @property apiIsSet
   * @description Computed property that checks if the API client has been initialized.
   * @returns {boolean} True if `this.api` is not null, false otherwise.
   * @computed
   */
  get apiIsSet() {
    return this.api !== null;
  }

  /**
   * @method apiCall
   * @template TGenericApi - The API client type used for this specific call. Defaults to `TApi` (the store's primary API type).
   * @template TGenericEndpoint - A key (method name) of `TGenericApi`.
   * @template TEndpointArgs - The type of the arguments for the specified `TGenericEndpoint`.
   * @description A MobX flow-wrapped method for making generic API calls using the initialized API client (`this.api`).
   *              It automatically handles setting the store's loading state before and after the call.
   * @param {TGenericEndpoint} endpoint - The name of the API method to call (must be a key of `TApi`).
   * @param {TEndpointArgs} args - The arguments to pass to the API method.
   * @returns {Promise<any>} A promise that resolves with the result of the API call. The actual return type depends on the called API endpoint.
   * @throws {Error} If the API client (`this.api`) has not been initialized.
   * @flow
   */
  apiCall = flow(
    toFlowGeneratorFunction(
      async <
        Api extends ApiType = TApi, // Internal generic for the API type
        Endpoint extends keyof Api = keyof Api, // Internal generic for the endpoint key
        // @ts-expect-error marks as error but works
        Args extends Parameters<Api[Endpoint]>[0] = Parameters<
          // @ts-expect-error marks as error but works
          TApi[Endpoint]
        >[0],
      >(
        endpoint: Endpoint, // This is the actual parameter name for the endpoint
        args: Args extends undefined ? never : Args, // This is the actual parameter name for arguments
      ) => {
        try {
          if (!this.api) throw new Error(`${this.name} Api is not set`);
          this.setIsLoading(true);
          // @ts-expect-error marks as error but works
          return await callApi<Api, Endpoint, Args>(endpoint, args, this.api);
        } finally {
          this.setIsLoading(false);
        }
      },
    ),
  );
}
